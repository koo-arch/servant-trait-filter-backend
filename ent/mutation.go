// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/koo-arch/servant-trait-filter-backend/ent/ascension"
	"github.com/koo-arch/servant-trait-filter-backend/ent/attribute"
	"github.com/koo-arch/servant-trait-filter-backend/ent/class"
	"github.com/koo-arch/servant-trait-filter-backend/ent/moralalignment"
	"github.com/koo-arch/servant-trait-filter-backend/ent/orderalignment"
	"github.com/koo-arch/servant-trait-filter-backend/ent/predicate"
	"github.com/koo-arch/servant-trait-filter-backend/ent/servant"
	"github.com/koo-arch/servant-trait-filter-backend/ent/trait"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAscension      = "Ascension"
	TypeAttribute      = "Attribute"
	TypeClass          = "Class"
	TypeMoralAlignment = "MoralAlignment"
	TypeOrderAlignment = "OrderAlignment"
	TypeServant        = "Servant"
	TypeTrait          = "Trait"
)

// AscensionMutation represents an operation that mutates the Ascension nodes in the graph.
type AscensionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	stage                  *int
	addstage               *int
	clearedFields          map[string]struct{}
	servant                *int
	clearedservant         bool
	attribute              *int
	clearedattribute       bool
	order_alignment        *int
	clearedorder_alignment bool
	moral_alignment        *int
	clearedmoral_alignment bool
	done                   bool
	oldValue               func(context.Context) (*Ascension, error)
	predicates             []predicate.Ascension
}

var _ ent.Mutation = (*AscensionMutation)(nil)

// ascensionOption allows management of the mutation configuration using functional options.
type ascensionOption func(*AscensionMutation)

// newAscensionMutation creates new mutation for the Ascension entity.
func newAscensionMutation(c config, op Op, opts ...ascensionOption) *AscensionMutation {
	m := &AscensionMutation{
		config:        c,
		op:            op,
		typ:           TypeAscension,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAscensionID sets the ID field of the mutation.
func withAscensionID(id int) ascensionOption {
	return func(m *AscensionMutation) {
		var (
			err   error
			once  sync.Once
			value *Ascension
		)
		m.oldValue = func(ctx context.Context) (*Ascension, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ascension.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAscension sets the old Ascension of the mutation.
func withAscension(node *Ascension) ascensionOption {
	return func(m *AscensionMutation) {
		m.oldValue = func(context.Context) (*Ascension, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AscensionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AscensionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AscensionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AscensionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ascension.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AscensionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AscensionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ascension entity.
// If the Ascension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AscensionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AscensionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AscensionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AscensionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ascension entity.
// If the Ascension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AscensionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AscensionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetServantID sets the "servant_id" field.
func (m *AscensionMutation) SetServantID(i int) {
	m.servant = &i
}

// ServantID returns the value of the "servant_id" field in the mutation.
func (m *AscensionMutation) ServantID() (r int, exists bool) {
	v := m.servant
	if v == nil {
		return
	}
	return *v, true
}

// OldServantID returns the old "servant_id" field's value of the Ascension entity.
// If the Ascension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AscensionMutation) OldServantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServantID: %w", err)
	}
	return oldValue.ServantID, nil
}

// ResetServantID resets all changes to the "servant_id" field.
func (m *AscensionMutation) ResetServantID() {
	m.servant = nil
}

// SetStage sets the "stage" field.
func (m *AscensionMutation) SetStage(i int) {
	m.stage = &i
	m.addstage = nil
}

// Stage returns the value of the "stage" field in the mutation.
func (m *AscensionMutation) Stage() (r int, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStage returns the old "stage" field's value of the Ascension entity.
// If the Ascension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AscensionMutation) OldStage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStage: %w", err)
	}
	return oldValue.Stage, nil
}

// AddStage adds i to the "stage" field.
func (m *AscensionMutation) AddStage(i int) {
	if m.addstage != nil {
		*m.addstage += i
	} else {
		m.addstage = &i
	}
}

// AddedStage returns the value that was added to the "stage" field in this mutation.
func (m *AscensionMutation) AddedStage() (r int, exists bool) {
	v := m.addstage
	if v == nil {
		return
	}
	return *v, true
}

// ResetStage resets all changes to the "stage" field.
func (m *AscensionMutation) ResetStage() {
	m.stage = nil
	m.addstage = nil
}

// SetAttributeID sets the "attribute_id" field.
func (m *AscensionMutation) SetAttributeID(i int) {
	m.attribute = &i
}

// AttributeID returns the value of the "attribute_id" field in the mutation.
func (m *AscensionMutation) AttributeID() (r int, exists bool) {
	v := m.attribute
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeID returns the old "attribute_id" field's value of the Ascension entity.
// If the Ascension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AscensionMutation) OldAttributeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeID: %w", err)
	}
	return oldValue.AttributeID, nil
}

// ClearAttributeID clears the value of the "attribute_id" field.
func (m *AscensionMutation) ClearAttributeID() {
	m.attribute = nil
	m.clearedFields[ascension.FieldAttributeID] = struct{}{}
}

// AttributeIDCleared returns if the "attribute_id" field was cleared in this mutation.
func (m *AscensionMutation) AttributeIDCleared() bool {
	_, ok := m.clearedFields[ascension.FieldAttributeID]
	return ok
}

// ResetAttributeID resets all changes to the "attribute_id" field.
func (m *AscensionMutation) ResetAttributeID() {
	m.attribute = nil
	delete(m.clearedFields, ascension.FieldAttributeID)
}

// SetOrderAlignmentID sets the "order_alignment_id" field.
func (m *AscensionMutation) SetOrderAlignmentID(i int) {
	m.order_alignment = &i
}

// OrderAlignmentID returns the value of the "order_alignment_id" field in the mutation.
func (m *AscensionMutation) OrderAlignmentID() (r int, exists bool) {
	v := m.order_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAlignmentID returns the old "order_alignment_id" field's value of the Ascension entity.
// If the Ascension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AscensionMutation) OldOrderAlignmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAlignmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAlignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAlignmentID: %w", err)
	}
	return oldValue.OrderAlignmentID, nil
}

// ClearOrderAlignmentID clears the value of the "order_alignment_id" field.
func (m *AscensionMutation) ClearOrderAlignmentID() {
	m.order_alignment = nil
	m.clearedFields[ascension.FieldOrderAlignmentID] = struct{}{}
}

// OrderAlignmentIDCleared returns if the "order_alignment_id" field was cleared in this mutation.
func (m *AscensionMutation) OrderAlignmentIDCleared() bool {
	_, ok := m.clearedFields[ascension.FieldOrderAlignmentID]
	return ok
}

// ResetOrderAlignmentID resets all changes to the "order_alignment_id" field.
func (m *AscensionMutation) ResetOrderAlignmentID() {
	m.order_alignment = nil
	delete(m.clearedFields, ascension.FieldOrderAlignmentID)
}

// SetMoralAlignmentID sets the "moral_alignment_id" field.
func (m *AscensionMutation) SetMoralAlignmentID(i int) {
	m.moral_alignment = &i
}

// MoralAlignmentID returns the value of the "moral_alignment_id" field in the mutation.
func (m *AscensionMutation) MoralAlignmentID() (r int, exists bool) {
	v := m.moral_alignment
	if v == nil {
		return
	}
	return *v, true
}

// OldMoralAlignmentID returns the old "moral_alignment_id" field's value of the Ascension entity.
// If the Ascension object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AscensionMutation) OldMoralAlignmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoralAlignmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoralAlignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoralAlignmentID: %w", err)
	}
	return oldValue.MoralAlignmentID, nil
}

// ClearMoralAlignmentID clears the value of the "moral_alignment_id" field.
func (m *AscensionMutation) ClearMoralAlignmentID() {
	m.moral_alignment = nil
	m.clearedFields[ascension.FieldMoralAlignmentID] = struct{}{}
}

// MoralAlignmentIDCleared returns if the "moral_alignment_id" field was cleared in this mutation.
func (m *AscensionMutation) MoralAlignmentIDCleared() bool {
	_, ok := m.clearedFields[ascension.FieldMoralAlignmentID]
	return ok
}

// ResetMoralAlignmentID resets all changes to the "moral_alignment_id" field.
func (m *AscensionMutation) ResetMoralAlignmentID() {
	m.moral_alignment = nil
	delete(m.clearedFields, ascension.FieldMoralAlignmentID)
}

// ClearServant clears the "servant" edge to the Servant entity.
func (m *AscensionMutation) ClearServant() {
	m.clearedservant = true
	m.clearedFields[ascension.FieldServantID] = struct{}{}
}

// ServantCleared reports if the "servant" edge to the Servant entity was cleared.
func (m *AscensionMutation) ServantCleared() bool {
	return m.clearedservant
}

// ServantIDs returns the "servant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServantID instead. It exists only for internal usage by the builders.
func (m *AscensionMutation) ServantIDs() (ids []int) {
	if id := m.servant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServant resets all changes to the "servant" edge.
func (m *AscensionMutation) ResetServant() {
	m.servant = nil
	m.clearedservant = false
}

// ClearAttribute clears the "attribute" edge to the Attribute entity.
func (m *AscensionMutation) ClearAttribute() {
	m.clearedattribute = true
	m.clearedFields[ascension.FieldAttributeID] = struct{}{}
}

// AttributeCleared reports if the "attribute" edge to the Attribute entity was cleared.
func (m *AscensionMutation) AttributeCleared() bool {
	return m.AttributeIDCleared() || m.clearedattribute
}

// AttributeIDs returns the "attribute" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttributeID instead. It exists only for internal usage by the builders.
func (m *AscensionMutation) AttributeIDs() (ids []int) {
	if id := m.attribute; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttribute resets all changes to the "attribute" edge.
func (m *AscensionMutation) ResetAttribute() {
	m.attribute = nil
	m.clearedattribute = false
}

// ClearOrderAlignment clears the "order_alignment" edge to the OrderAlignment entity.
func (m *AscensionMutation) ClearOrderAlignment() {
	m.clearedorder_alignment = true
	m.clearedFields[ascension.FieldOrderAlignmentID] = struct{}{}
}

// OrderAlignmentCleared reports if the "order_alignment" edge to the OrderAlignment entity was cleared.
func (m *AscensionMutation) OrderAlignmentCleared() bool {
	return m.OrderAlignmentIDCleared() || m.clearedorder_alignment
}

// OrderAlignmentIDs returns the "order_alignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderAlignmentID instead. It exists only for internal usage by the builders.
func (m *AscensionMutation) OrderAlignmentIDs() (ids []int) {
	if id := m.order_alignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderAlignment resets all changes to the "order_alignment" edge.
func (m *AscensionMutation) ResetOrderAlignment() {
	m.order_alignment = nil
	m.clearedorder_alignment = false
}

// ClearMoralAlignment clears the "moral_alignment" edge to the MoralAlignment entity.
func (m *AscensionMutation) ClearMoralAlignment() {
	m.clearedmoral_alignment = true
	m.clearedFields[ascension.FieldMoralAlignmentID] = struct{}{}
}

// MoralAlignmentCleared reports if the "moral_alignment" edge to the MoralAlignment entity was cleared.
func (m *AscensionMutation) MoralAlignmentCleared() bool {
	return m.MoralAlignmentIDCleared() || m.clearedmoral_alignment
}

// MoralAlignmentIDs returns the "moral_alignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MoralAlignmentID instead. It exists only for internal usage by the builders.
func (m *AscensionMutation) MoralAlignmentIDs() (ids []int) {
	if id := m.moral_alignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMoralAlignment resets all changes to the "moral_alignment" edge.
func (m *AscensionMutation) ResetMoralAlignment() {
	m.moral_alignment = nil
	m.clearedmoral_alignment = false
}

// Where appends a list predicates to the AscensionMutation builder.
func (m *AscensionMutation) Where(ps ...predicate.Ascension) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AscensionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AscensionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ascension, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AscensionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AscensionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ascension).
func (m *AscensionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AscensionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, ascension.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ascension.FieldUpdatedAt)
	}
	if m.servant != nil {
		fields = append(fields, ascension.FieldServantID)
	}
	if m.stage != nil {
		fields = append(fields, ascension.FieldStage)
	}
	if m.attribute != nil {
		fields = append(fields, ascension.FieldAttributeID)
	}
	if m.order_alignment != nil {
		fields = append(fields, ascension.FieldOrderAlignmentID)
	}
	if m.moral_alignment != nil {
		fields = append(fields, ascension.FieldMoralAlignmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AscensionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ascension.FieldCreatedAt:
		return m.CreatedAt()
	case ascension.FieldUpdatedAt:
		return m.UpdatedAt()
	case ascension.FieldServantID:
		return m.ServantID()
	case ascension.FieldStage:
		return m.Stage()
	case ascension.FieldAttributeID:
		return m.AttributeID()
	case ascension.FieldOrderAlignmentID:
		return m.OrderAlignmentID()
	case ascension.FieldMoralAlignmentID:
		return m.MoralAlignmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AscensionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ascension.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ascension.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ascension.FieldServantID:
		return m.OldServantID(ctx)
	case ascension.FieldStage:
		return m.OldStage(ctx)
	case ascension.FieldAttributeID:
		return m.OldAttributeID(ctx)
	case ascension.FieldOrderAlignmentID:
		return m.OldOrderAlignmentID(ctx)
	case ascension.FieldMoralAlignmentID:
		return m.OldMoralAlignmentID(ctx)
	}
	return nil, fmt.Errorf("unknown Ascension field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AscensionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ascension.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ascension.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ascension.FieldServantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServantID(v)
		return nil
	case ascension.FieldStage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStage(v)
		return nil
	case ascension.FieldAttributeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeID(v)
		return nil
	case ascension.FieldOrderAlignmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAlignmentID(v)
		return nil
	case ascension.FieldMoralAlignmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoralAlignmentID(v)
		return nil
	}
	return fmt.Errorf("unknown Ascension field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AscensionMutation) AddedFields() []string {
	var fields []string
	if m.addstage != nil {
		fields = append(fields, ascension.FieldStage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AscensionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ascension.FieldStage:
		return m.AddedStage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AscensionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ascension.FieldStage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStage(v)
		return nil
	}
	return fmt.Errorf("unknown Ascension numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AscensionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ascension.FieldAttributeID) {
		fields = append(fields, ascension.FieldAttributeID)
	}
	if m.FieldCleared(ascension.FieldOrderAlignmentID) {
		fields = append(fields, ascension.FieldOrderAlignmentID)
	}
	if m.FieldCleared(ascension.FieldMoralAlignmentID) {
		fields = append(fields, ascension.FieldMoralAlignmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AscensionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AscensionMutation) ClearField(name string) error {
	switch name {
	case ascension.FieldAttributeID:
		m.ClearAttributeID()
		return nil
	case ascension.FieldOrderAlignmentID:
		m.ClearOrderAlignmentID()
		return nil
	case ascension.FieldMoralAlignmentID:
		m.ClearMoralAlignmentID()
		return nil
	}
	return fmt.Errorf("unknown Ascension nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AscensionMutation) ResetField(name string) error {
	switch name {
	case ascension.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ascension.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ascension.FieldServantID:
		m.ResetServantID()
		return nil
	case ascension.FieldStage:
		m.ResetStage()
		return nil
	case ascension.FieldAttributeID:
		m.ResetAttributeID()
		return nil
	case ascension.FieldOrderAlignmentID:
		m.ResetOrderAlignmentID()
		return nil
	case ascension.FieldMoralAlignmentID:
		m.ResetMoralAlignmentID()
		return nil
	}
	return fmt.Errorf("unknown Ascension field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AscensionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.servant != nil {
		edges = append(edges, ascension.EdgeServant)
	}
	if m.attribute != nil {
		edges = append(edges, ascension.EdgeAttribute)
	}
	if m.order_alignment != nil {
		edges = append(edges, ascension.EdgeOrderAlignment)
	}
	if m.moral_alignment != nil {
		edges = append(edges, ascension.EdgeMoralAlignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AscensionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ascension.EdgeServant:
		if id := m.servant; id != nil {
			return []ent.Value{*id}
		}
	case ascension.EdgeAttribute:
		if id := m.attribute; id != nil {
			return []ent.Value{*id}
		}
	case ascension.EdgeOrderAlignment:
		if id := m.order_alignment; id != nil {
			return []ent.Value{*id}
		}
	case ascension.EdgeMoralAlignment:
		if id := m.moral_alignment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AscensionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AscensionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AscensionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedservant {
		edges = append(edges, ascension.EdgeServant)
	}
	if m.clearedattribute {
		edges = append(edges, ascension.EdgeAttribute)
	}
	if m.clearedorder_alignment {
		edges = append(edges, ascension.EdgeOrderAlignment)
	}
	if m.clearedmoral_alignment {
		edges = append(edges, ascension.EdgeMoralAlignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AscensionMutation) EdgeCleared(name string) bool {
	switch name {
	case ascension.EdgeServant:
		return m.clearedservant
	case ascension.EdgeAttribute:
		return m.clearedattribute
	case ascension.EdgeOrderAlignment:
		return m.clearedorder_alignment
	case ascension.EdgeMoralAlignment:
		return m.clearedmoral_alignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AscensionMutation) ClearEdge(name string) error {
	switch name {
	case ascension.EdgeServant:
		m.ClearServant()
		return nil
	case ascension.EdgeAttribute:
		m.ClearAttribute()
		return nil
	case ascension.EdgeOrderAlignment:
		m.ClearOrderAlignment()
		return nil
	case ascension.EdgeMoralAlignment:
		m.ClearMoralAlignment()
		return nil
	}
	return fmt.Errorf("unknown Ascension unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AscensionMutation) ResetEdge(name string) error {
	switch name {
	case ascension.EdgeServant:
		m.ResetServant()
		return nil
	case ascension.EdgeAttribute:
		m.ResetAttribute()
		return nil
	case ascension.EdgeOrderAlignment:
		m.ResetOrderAlignment()
		return nil
	case ascension.EdgeMoralAlignment:
		m.ResetMoralAlignment()
		return nil
	}
	return fmt.Errorf("unknown Ascension edge %s", name)
}

// AttributeMutation represents an operation that mutates the Attribute nodes in the graph.
type AttributeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name_en           *string
	name_ja           *string
	clearedFields     map[string]struct{}
	ascensions        map[int]struct{}
	removedascensions map[int]struct{}
	clearedascensions bool
	done              bool
	oldValue          func(context.Context) (*Attribute, error)
	predicates        []predicate.Attribute
}

var _ ent.Mutation = (*AttributeMutation)(nil)

// attributeOption allows management of the mutation configuration using functional options.
type attributeOption func(*AttributeMutation)

// newAttributeMutation creates new mutation for the Attribute entity.
func newAttributeMutation(c config, op Op, opts ...attributeOption) *AttributeMutation {
	m := &AttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeID sets the ID field of the mutation.
func withAttributeID(id int) attributeOption {
	return func(m *AttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *Attribute
		)
		m.oldValue = func(ctx context.Context) (*Attribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttribute sets the old Attribute of the mutation.
func withAttribute(node *Attribute) attributeOption {
	return func(m *AttributeMutation) {
		m.oldValue = func(context.Context) (*Attribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attribute entities.
func (m *AttributeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttributeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttributeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttributeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttributeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttributeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttributeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNameEn sets the "name_en" field.
func (m *AttributeMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *AttributeMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *AttributeMutation) ResetNameEn() {
	m.name_en = nil
}

// SetNameJa sets the "name_ja" field.
func (m *AttributeMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *AttributeMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *AttributeMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[attribute.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *AttributeMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[attribute.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *AttributeMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, attribute.FieldNameJa)
}

// AddAscensionIDs adds the "ascensions" edge to the Ascension entity by ids.
func (m *AttributeMutation) AddAscensionIDs(ids ...int) {
	if m.ascensions == nil {
		m.ascensions = make(map[int]struct{})
	}
	for i := range ids {
		m.ascensions[ids[i]] = struct{}{}
	}
}

// ClearAscensions clears the "ascensions" edge to the Ascension entity.
func (m *AttributeMutation) ClearAscensions() {
	m.clearedascensions = true
}

// AscensionsCleared reports if the "ascensions" edge to the Ascension entity was cleared.
func (m *AttributeMutation) AscensionsCleared() bool {
	return m.clearedascensions
}

// RemoveAscensionIDs removes the "ascensions" edge to the Ascension entity by IDs.
func (m *AttributeMutation) RemoveAscensionIDs(ids ...int) {
	if m.removedascensions == nil {
		m.removedascensions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ascensions, ids[i])
		m.removedascensions[ids[i]] = struct{}{}
	}
}

// RemovedAscensions returns the removed IDs of the "ascensions" edge to the Ascension entity.
func (m *AttributeMutation) RemovedAscensionsIDs() (ids []int) {
	for id := range m.removedascensions {
		ids = append(ids, id)
	}
	return
}

// AscensionsIDs returns the "ascensions" edge IDs in the mutation.
func (m *AttributeMutation) AscensionsIDs() (ids []int) {
	for id := range m.ascensions {
		ids = append(ids, id)
	}
	return
}

// ResetAscensions resets all changes to the "ascensions" edge.
func (m *AttributeMutation) ResetAscensions() {
	m.ascensions = nil
	m.clearedascensions = false
	m.removedascensions = nil
}

// Where appends a list predicates to the AttributeMutation builder.
func (m *AttributeMutation) Where(ps ...predicate.Attribute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attribute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attribute).
func (m *AttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, attribute.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attribute.FieldUpdatedAt)
	}
	if m.name_en != nil {
		fields = append(fields, attribute.FieldNameEn)
	}
	if m.name_ja != nil {
		fields = append(fields, attribute.FieldNameJa)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldCreatedAt:
		return m.CreatedAt()
	case attribute.FieldUpdatedAt:
		return m.UpdatedAt()
	case attribute.FieldNameEn:
		return m.NameEn()
	case attribute.FieldNameJa:
		return m.NameJa()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attribute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attribute.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attribute.FieldNameEn:
		return m.OldNameEn(ctx)
	case attribute.FieldNameJa:
		return m.OldNameJa(ctx)
	}
	return nil, fmt.Errorf("unknown Attribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attribute.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attribute.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	case attribute.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attribute.FieldNameJa) {
		fields = append(fields, attribute.FieldNameJa)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeMutation) ClearField(name string) error {
	switch name {
	case attribute.FieldNameJa:
		m.ClearNameJa()
		return nil
	}
	return fmt.Errorf("unknown Attribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeMutation) ResetField(name string) error {
	switch name {
	case attribute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attribute.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attribute.FieldNameEn:
		m.ResetNameEn()
		return nil
	case attribute.FieldNameJa:
		m.ResetNameJa()
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ascensions != nil {
		edges = append(edges, attribute.EdgeAscensions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.ascensions))
		for id := range m.ascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedascensions != nil {
		edges = append(edges, attribute.EdgeAscensions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.removedascensions))
		for id := range m.removedascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedascensions {
		edges = append(edges, attribute.EdgeAscensions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case attribute.EdgeAscensions:
		return m.clearedascensions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Attribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeMutation) ResetEdge(name string) error {
	switch name {
	case attribute.EdgeAscensions:
		m.ResetAscensions()
		return nil
	}
	return fmt.Errorf("unknown Attribute edge %s", name)
}

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name_en         *string
	name_ja         *string
	clearedFields   map[string]struct{}
	servants        map[int]struct{}
	removedservants map[int]struct{}
	clearedservants bool
	done            bool
	oldValue        func(context.Context) (*Class, error)
	predicates      []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id int) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Class entities.
func (m *ClassMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNameEn sets the "name_en" field.
func (m *ClassMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *ClassMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *ClassMutation) ResetNameEn() {
	m.name_en = nil
}

// SetNameJa sets the "name_ja" field.
func (m *ClassMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *ClassMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *ClassMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[class.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *ClassMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[class.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *ClassMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, class.FieldNameJa)
}

// AddServantIDs adds the "servants" edge to the Servant entity by ids.
func (m *ClassMutation) AddServantIDs(ids ...int) {
	if m.servants == nil {
		m.servants = make(map[int]struct{})
	}
	for i := range ids {
		m.servants[ids[i]] = struct{}{}
	}
}

// ClearServants clears the "servants" edge to the Servant entity.
func (m *ClassMutation) ClearServants() {
	m.clearedservants = true
}

// ServantsCleared reports if the "servants" edge to the Servant entity was cleared.
func (m *ClassMutation) ServantsCleared() bool {
	return m.clearedservants
}

// RemoveServantIDs removes the "servants" edge to the Servant entity by IDs.
func (m *ClassMutation) RemoveServantIDs(ids ...int) {
	if m.removedservants == nil {
		m.removedservants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.servants, ids[i])
		m.removedservants[ids[i]] = struct{}{}
	}
}

// RemovedServants returns the removed IDs of the "servants" edge to the Servant entity.
func (m *ClassMutation) RemovedServantsIDs() (ids []int) {
	for id := range m.removedservants {
		ids = append(ids, id)
	}
	return
}

// ServantsIDs returns the "servants" edge IDs in the mutation.
func (m *ClassMutation) ServantsIDs() (ids []int) {
	for id := range m.servants {
		ids = append(ids, id)
	}
	return
}

// ResetServants resets all changes to the "servants" edge.
func (m *ClassMutation) ResetServants() {
	m.servants = nil
	m.clearedservants = false
	m.removedservants = nil
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, class.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, class.FieldUpdatedAt)
	}
	if m.name_en != nil {
		fields = append(fields, class.FieldNameEn)
	}
	if m.name_ja != nil {
		fields = append(fields, class.FieldNameJa)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldCreatedAt:
		return m.CreatedAt()
	case class.FieldUpdatedAt:
		return m.UpdatedAt()
	case class.FieldNameEn:
		return m.NameEn()
	case class.FieldNameJa:
		return m.NameJa()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case class.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case class.FieldNameEn:
		return m.OldNameEn(ctx)
	case class.FieldNameJa:
		return m.OldNameJa(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case class.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case class.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	case class.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(class.FieldNameJa) {
		fields = append(fields, class.FieldNameJa)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	switch name {
	case class.FieldNameJa:
		m.ClearNameJa()
		return nil
	}
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case class.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case class.FieldNameEn:
		m.ResetNameEn()
		return nil
	case class.FieldNameJa:
		m.ResetNameJa()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.servants != nil {
		edges = append(edges, class.EdgeServants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeServants:
		ids := make([]ent.Value, 0, len(m.servants))
		for id := range m.servants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservants != nil {
		edges = append(edges, class.EdgeServants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeServants:
		ids := make([]ent.Value, 0, len(m.removedservants))
		for id := range m.removedservants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservants {
		edges = append(edges, class.EdgeServants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeServants:
		return m.clearedservants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeServants:
		m.ResetServants()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// MoralAlignmentMutation represents an operation that mutates the MoralAlignment nodes in the graph.
type MoralAlignmentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name_en           *string
	name_ja           *string
	clearedFields     map[string]struct{}
	ascensions        map[int]struct{}
	removedascensions map[int]struct{}
	clearedascensions bool
	done              bool
	oldValue          func(context.Context) (*MoralAlignment, error)
	predicates        []predicate.MoralAlignment
}

var _ ent.Mutation = (*MoralAlignmentMutation)(nil)

// moralalignmentOption allows management of the mutation configuration using functional options.
type moralalignmentOption func(*MoralAlignmentMutation)

// newMoralAlignmentMutation creates new mutation for the MoralAlignment entity.
func newMoralAlignmentMutation(c config, op Op, opts ...moralalignmentOption) *MoralAlignmentMutation {
	m := &MoralAlignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeMoralAlignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMoralAlignmentID sets the ID field of the mutation.
func withMoralAlignmentID(id int) moralalignmentOption {
	return func(m *MoralAlignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *MoralAlignment
		)
		m.oldValue = func(ctx context.Context) (*MoralAlignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MoralAlignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMoralAlignment sets the old MoralAlignment of the mutation.
func withMoralAlignment(node *MoralAlignment) moralalignmentOption {
	return func(m *MoralAlignmentMutation) {
		m.oldValue = func(context.Context) (*MoralAlignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MoralAlignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MoralAlignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MoralAlignment entities.
func (m *MoralAlignmentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MoralAlignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MoralAlignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MoralAlignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MoralAlignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MoralAlignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MoralAlignment entity.
// If the MoralAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoralAlignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MoralAlignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MoralAlignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MoralAlignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MoralAlignment entity.
// If the MoralAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoralAlignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MoralAlignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNameEn sets the "name_en" field.
func (m *MoralAlignmentMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *MoralAlignmentMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the MoralAlignment entity.
// If the MoralAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoralAlignmentMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *MoralAlignmentMutation) ResetNameEn() {
	m.name_en = nil
}

// SetNameJa sets the "name_ja" field.
func (m *MoralAlignmentMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *MoralAlignmentMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the MoralAlignment entity.
// If the MoralAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoralAlignmentMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *MoralAlignmentMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[moralalignment.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *MoralAlignmentMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[moralalignment.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *MoralAlignmentMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, moralalignment.FieldNameJa)
}

// AddAscensionIDs adds the "ascensions" edge to the Ascension entity by ids.
func (m *MoralAlignmentMutation) AddAscensionIDs(ids ...int) {
	if m.ascensions == nil {
		m.ascensions = make(map[int]struct{})
	}
	for i := range ids {
		m.ascensions[ids[i]] = struct{}{}
	}
}

// ClearAscensions clears the "ascensions" edge to the Ascension entity.
func (m *MoralAlignmentMutation) ClearAscensions() {
	m.clearedascensions = true
}

// AscensionsCleared reports if the "ascensions" edge to the Ascension entity was cleared.
func (m *MoralAlignmentMutation) AscensionsCleared() bool {
	return m.clearedascensions
}

// RemoveAscensionIDs removes the "ascensions" edge to the Ascension entity by IDs.
func (m *MoralAlignmentMutation) RemoveAscensionIDs(ids ...int) {
	if m.removedascensions == nil {
		m.removedascensions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ascensions, ids[i])
		m.removedascensions[ids[i]] = struct{}{}
	}
}

// RemovedAscensions returns the removed IDs of the "ascensions" edge to the Ascension entity.
func (m *MoralAlignmentMutation) RemovedAscensionsIDs() (ids []int) {
	for id := range m.removedascensions {
		ids = append(ids, id)
	}
	return
}

// AscensionsIDs returns the "ascensions" edge IDs in the mutation.
func (m *MoralAlignmentMutation) AscensionsIDs() (ids []int) {
	for id := range m.ascensions {
		ids = append(ids, id)
	}
	return
}

// ResetAscensions resets all changes to the "ascensions" edge.
func (m *MoralAlignmentMutation) ResetAscensions() {
	m.ascensions = nil
	m.clearedascensions = false
	m.removedascensions = nil
}

// Where appends a list predicates to the MoralAlignmentMutation builder.
func (m *MoralAlignmentMutation) Where(ps ...predicate.MoralAlignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MoralAlignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MoralAlignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MoralAlignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MoralAlignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MoralAlignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MoralAlignment).
func (m *MoralAlignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MoralAlignmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, moralalignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, moralalignment.FieldUpdatedAt)
	}
	if m.name_en != nil {
		fields = append(fields, moralalignment.FieldNameEn)
	}
	if m.name_ja != nil {
		fields = append(fields, moralalignment.FieldNameJa)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MoralAlignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moralalignment.FieldCreatedAt:
		return m.CreatedAt()
	case moralalignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case moralalignment.FieldNameEn:
		return m.NameEn()
	case moralalignment.FieldNameJa:
		return m.NameJa()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MoralAlignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case moralalignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case moralalignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case moralalignment.FieldNameEn:
		return m.OldNameEn(ctx)
	case moralalignment.FieldNameJa:
		return m.OldNameJa(ctx)
	}
	return nil, fmt.Errorf("unknown MoralAlignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoralAlignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moralalignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case moralalignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case moralalignment.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	case moralalignment.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	}
	return fmt.Errorf("unknown MoralAlignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MoralAlignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MoralAlignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoralAlignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MoralAlignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MoralAlignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(moralalignment.FieldNameJa) {
		fields = append(fields, moralalignment.FieldNameJa)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MoralAlignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MoralAlignmentMutation) ClearField(name string) error {
	switch name {
	case moralalignment.FieldNameJa:
		m.ClearNameJa()
		return nil
	}
	return fmt.Errorf("unknown MoralAlignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MoralAlignmentMutation) ResetField(name string) error {
	switch name {
	case moralalignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case moralalignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case moralalignment.FieldNameEn:
		m.ResetNameEn()
		return nil
	case moralalignment.FieldNameJa:
		m.ResetNameJa()
		return nil
	}
	return fmt.Errorf("unknown MoralAlignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MoralAlignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ascensions != nil {
		edges = append(edges, moralalignment.EdgeAscensions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MoralAlignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moralalignment.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.ascensions))
		for id := range m.ascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MoralAlignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedascensions != nil {
		edges = append(edges, moralalignment.EdgeAscensions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MoralAlignmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case moralalignment.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.removedascensions))
		for id := range m.removedascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MoralAlignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedascensions {
		edges = append(edges, moralalignment.EdgeAscensions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MoralAlignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case moralalignment.EdgeAscensions:
		return m.clearedascensions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MoralAlignmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MoralAlignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MoralAlignmentMutation) ResetEdge(name string) error {
	switch name {
	case moralalignment.EdgeAscensions:
		m.ResetAscensions()
		return nil
	}
	return fmt.Errorf("unknown MoralAlignment edge %s", name)
}

// OrderAlignmentMutation represents an operation that mutates the OrderAlignment nodes in the graph.
type OrderAlignmentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name_en           *string
	name_ja           *string
	clearedFields     map[string]struct{}
	ascensions        map[int]struct{}
	removedascensions map[int]struct{}
	clearedascensions bool
	done              bool
	oldValue          func(context.Context) (*OrderAlignment, error)
	predicates        []predicate.OrderAlignment
}

var _ ent.Mutation = (*OrderAlignmentMutation)(nil)

// orderalignmentOption allows management of the mutation configuration using functional options.
type orderalignmentOption func(*OrderAlignmentMutation)

// newOrderAlignmentMutation creates new mutation for the OrderAlignment entity.
func newOrderAlignmentMutation(c config, op Op, opts ...orderalignmentOption) *OrderAlignmentMutation {
	m := &OrderAlignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAlignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAlignmentID sets the ID field of the mutation.
func withOrderAlignmentID(id int) orderalignmentOption {
	return func(m *OrderAlignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAlignment
		)
		m.oldValue = func(ctx context.Context) (*OrderAlignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAlignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAlignment sets the old OrderAlignment of the mutation.
func withOrderAlignment(node *OrderAlignment) orderalignmentOption {
	return func(m *OrderAlignmentMutation) {
		m.oldValue = func(context.Context) (*OrderAlignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAlignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAlignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderAlignment entities.
func (m *OrderAlignmentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAlignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderAlignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderAlignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderAlignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderAlignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderAlignment entity.
// If the OrderAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAlignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderAlignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderAlignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderAlignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderAlignment entity.
// If the OrderAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAlignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderAlignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNameEn sets the "name_en" field.
func (m *OrderAlignmentMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *OrderAlignmentMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the OrderAlignment entity.
// If the OrderAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAlignmentMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *OrderAlignmentMutation) ResetNameEn() {
	m.name_en = nil
}

// SetNameJa sets the "name_ja" field.
func (m *OrderAlignmentMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *OrderAlignmentMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the OrderAlignment entity.
// If the OrderAlignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAlignmentMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *OrderAlignmentMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[orderalignment.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *OrderAlignmentMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[orderalignment.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *OrderAlignmentMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, orderalignment.FieldNameJa)
}

// AddAscensionIDs adds the "ascensions" edge to the Ascension entity by ids.
func (m *OrderAlignmentMutation) AddAscensionIDs(ids ...int) {
	if m.ascensions == nil {
		m.ascensions = make(map[int]struct{})
	}
	for i := range ids {
		m.ascensions[ids[i]] = struct{}{}
	}
}

// ClearAscensions clears the "ascensions" edge to the Ascension entity.
func (m *OrderAlignmentMutation) ClearAscensions() {
	m.clearedascensions = true
}

// AscensionsCleared reports if the "ascensions" edge to the Ascension entity was cleared.
func (m *OrderAlignmentMutation) AscensionsCleared() bool {
	return m.clearedascensions
}

// RemoveAscensionIDs removes the "ascensions" edge to the Ascension entity by IDs.
func (m *OrderAlignmentMutation) RemoveAscensionIDs(ids ...int) {
	if m.removedascensions == nil {
		m.removedascensions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ascensions, ids[i])
		m.removedascensions[ids[i]] = struct{}{}
	}
}

// RemovedAscensions returns the removed IDs of the "ascensions" edge to the Ascension entity.
func (m *OrderAlignmentMutation) RemovedAscensionsIDs() (ids []int) {
	for id := range m.removedascensions {
		ids = append(ids, id)
	}
	return
}

// AscensionsIDs returns the "ascensions" edge IDs in the mutation.
func (m *OrderAlignmentMutation) AscensionsIDs() (ids []int) {
	for id := range m.ascensions {
		ids = append(ids, id)
	}
	return
}

// ResetAscensions resets all changes to the "ascensions" edge.
func (m *OrderAlignmentMutation) ResetAscensions() {
	m.ascensions = nil
	m.clearedascensions = false
	m.removedascensions = nil
}

// Where appends a list predicates to the OrderAlignmentMutation builder.
func (m *OrderAlignmentMutation) Where(ps ...predicate.OrderAlignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderAlignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderAlignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderAlignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderAlignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderAlignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderAlignment).
func (m *OrderAlignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAlignmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, orderalignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderalignment.FieldUpdatedAt)
	}
	if m.name_en != nil {
		fields = append(fields, orderalignment.FieldNameEn)
	}
	if m.name_ja != nil {
		fields = append(fields, orderalignment.FieldNameJa)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAlignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderalignment.FieldCreatedAt:
		return m.CreatedAt()
	case orderalignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderalignment.FieldNameEn:
		return m.NameEn()
	case orderalignment.FieldNameJa:
		return m.NameJa()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAlignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderalignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderalignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderalignment.FieldNameEn:
		return m.OldNameEn(ctx)
	case orderalignment.FieldNameJa:
		return m.OldNameJa(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAlignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAlignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderalignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderalignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderalignment.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	case orderalignment.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAlignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAlignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAlignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAlignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderAlignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAlignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderalignment.FieldNameJa) {
		fields = append(fields, orderalignment.FieldNameJa)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAlignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAlignmentMutation) ClearField(name string) error {
	switch name {
	case orderalignment.FieldNameJa:
		m.ClearNameJa()
		return nil
	}
	return fmt.Errorf("unknown OrderAlignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAlignmentMutation) ResetField(name string) error {
	switch name {
	case orderalignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderalignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderalignment.FieldNameEn:
		m.ResetNameEn()
		return nil
	case orderalignment.FieldNameJa:
		m.ResetNameJa()
		return nil
	}
	return fmt.Errorf("unknown OrderAlignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAlignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ascensions != nil {
		edges = append(edges, orderalignment.EdgeAscensions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAlignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderalignment.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.ascensions))
		for id := range m.ascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAlignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedascensions != nil {
		edges = append(edges, orderalignment.EdgeAscensions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAlignmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderalignment.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.removedascensions))
		for id := range m.removedascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAlignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedascensions {
		edges = append(edges, orderalignment.EdgeAscensions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAlignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case orderalignment.EdgeAscensions:
		return m.clearedascensions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAlignmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderAlignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAlignmentMutation) ResetEdge(name string) error {
	switch name {
	case orderalignment.EdgeAscensions:
		m.ResetAscensions()
		return nil
	}
	return fmt.Errorf("unknown OrderAlignment edge %s", name)
}

// ServantMutation represents an operation that mutates the Servant nodes in the graph.
type ServantMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	collection_no     *int
	addcollection_no  *int
	name              *string
	face              *string
	clearedFields     map[string]struct{}
	class             *int
	clearedclass      bool
	traits            map[int]struct{}
	removedtraits     map[int]struct{}
	clearedtraits     bool
	ascensions        map[int]struct{}
	removedascensions map[int]struct{}
	clearedascensions bool
	done              bool
	oldValue          func(context.Context) (*Servant, error)
	predicates        []predicate.Servant
}

var _ ent.Mutation = (*ServantMutation)(nil)

// servantOption allows management of the mutation configuration using functional options.
type servantOption func(*ServantMutation)

// newServantMutation creates new mutation for the Servant entity.
func newServantMutation(c config, op Op, opts ...servantOption) *ServantMutation {
	m := &ServantMutation{
		config:        c,
		op:            op,
		typ:           TypeServant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServantID sets the ID field of the mutation.
func withServantID(id int) servantOption {
	return func(m *ServantMutation) {
		var (
			err   error
			once  sync.Once
			value *Servant
		)
		m.oldValue = func(ctx context.Context) (*Servant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Servant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServant sets the old Servant of the mutation.
func withServant(node *Servant) servantOption {
	return func(m *ServantMutation) {
		m.oldValue = func(context.Context) (*Servant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Servant entities.
func (m *ServantMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Servant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Servant entity.
// If the Servant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Servant entity.
// If the Servant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCollectionNo sets the "collection_no" field.
func (m *ServantMutation) SetCollectionNo(i int) {
	m.collection_no = &i
	m.addcollection_no = nil
}

// CollectionNo returns the value of the "collection_no" field in the mutation.
func (m *ServantMutation) CollectionNo() (r int, exists bool) {
	v := m.collection_no
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionNo returns the old "collection_no" field's value of the Servant entity.
// If the Servant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServantMutation) OldCollectionNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionNo: %w", err)
	}
	return oldValue.CollectionNo, nil
}

// AddCollectionNo adds i to the "collection_no" field.
func (m *ServantMutation) AddCollectionNo(i int) {
	if m.addcollection_no != nil {
		*m.addcollection_no += i
	} else {
		m.addcollection_no = &i
	}
}

// AddedCollectionNo returns the value that was added to the "collection_no" field in this mutation.
func (m *ServantMutation) AddedCollectionNo() (r int, exists bool) {
	v := m.addcollection_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetCollectionNo resets all changes to the "collection_no" field.
func (m *ServantMutation) ResetCollectionNo() {
	m.collection_no = nil
	m.addcollection_no = nil
}

// SetName sets the "name" field.
func (m *ServantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Servant entity.
// If the Servant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServantMutation) ResetName() {
	m.name = nil
}

// SetFace sets the "face" field.
func (m *ServantMutation) SetFace(s string) {
	m.face = &s
}

// Face returns the value of the "face" field in the mutation.
func (m *ServantMutation) Face() (r string, exists bool) {
	v := m.face
	if v == nil {
		return
	}
	return *v, true
}

// OldFace returns the old "face" field's value of the Servant entity.
// If the Servant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServantMutation) OldFace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFace: %w", err)
	}
	return oldValue.Face, nil
}

// ResetFace resets all changes to the "face" field.
func (m *ServantMutation) ResetFace() {
	m.face = nil
}

// SetClassID sets the "class_id" field.
func (m *ServantMutation) SetClassID(i int) {
	m.class = &i
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *ServantMutation) ClassID() (r int, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the Servant entity.
// If the Servant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServantMutation) OldClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ResetClassID resets all changes to the "class_id" field.
func (m *ServantMutation) ResetClassID() {
	m.class = nil
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ServantMutation) ClearClass() {
	m.clearedclass = true
	m.clearedFields[servant.FieldClassID] = struct{}{}
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ServantMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ServantMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ServantMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// AddTraitIDs adds the "traits" edge to the Trait entity by ids.
func (m *ServantMutation) AddTraitIDs(ids ...int) {
	if m.traits == nil {
		m.traits = make(map[int]struct{})
	}
	for i := range ids {
		m.traits[ids[i]] = struct{}{}
	}
}

// ClearTraits clears the "traits" edge to the Trait entity.
func (m *ServantMutation) ClearTraits() {
	m.clearedtraits = true
}

// TraitsCleared reports if the "traits" edge to the Trait entity was cleared.
func (m *ServantMutation) TraitsCleared() bool {
	return m.clearedtraits
}

// RemoveTraitIDs removes the "traits" edge to the Trait entity by IDs.
func (m *ServantMutation) RemoveTraitIDs(ids ...int) {
	if m.removedtraits == nil {
		m.removedtraits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traits, ids[i])
		m.removedtraits[ids[i]] = struct{}{}
	}
}

// RemovedTraits returns the removed IDs of the "traits" edge to the Trait entity.
func (m *ServantMutation) RemovedTraitsIDs() (ids []int) {
	for id := range m.removedtraits {
		ids = append(ids, id)
	}
	return
}

// TraitsIDs returns the "traits" edge IDs in the mutation.
func (m *ServantMutation) TraitsIDs() (ids []int) {
	for id := range m.traits {
		ids = append(ids, id)
	}
	return
}

// ResetTraits resets all changes to the "traits" edge.
func (m *ServantMutation) ResetTraits() {
	m.traits = nil
	m.clearedtraits = false
	m.removedtraits = nil
}

// AddAscensionIDs adds the "ascensions" edge to the Ascension entity by ids.
func (m *ServantMutation) AddAscensionIDs(ids ...int) {
	if m.ascensions == nil {
		m.ascensions = make(map[int]struct{})
	}
	for i := range ids {
		m.ascensions[ids[i]] = struct{}{}
	}
}

// ClearAscensions clears the "ascensions" edge to the Ascension entity.
func (m *ServantMutation) ClearAscensions() {
	m.clearedascensions = true
}

// AscensionsCleared reports if the "ascensions" edge to the Ascension entity was cleared.
func (m *ServantMutation) AscensionsCleared() bool {
	return m.clearedascensions
}

// RemoveAscensionIDs removes the "ascensions" edge to the Ascension entity by IDs.
func (m *ServantMutation) RemoveAscensionIDs(ids ...int) {
	if m.removedascensions == nil {
		m.removedascensions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ascensions, ids[i])
		m.removedascensions[ids[i]] = struct{}{}
	}
}

// RemovedAscensions returns the removed IDs of the "ascensions" edge to the Ascension entity.
func (m *ServantMutation) RemovedAscensionsIDs() (ids []int) {
	for id := range m.removedascensions {
		ids = append(ids, id)
	}
	return
}

// AscensionsIDs returns the "ascensions" edge IDs in the mutation.
func (m *ServantMutation) AscensionsIDs() (ids []int) {
	for id := range m.ascensions {
		ids = append(ids, id)
	}
	return
}

// ResetAscensions resets all changes to the "ascensions" edge.
func (m *ServantMutation) ResetAscensions() {
	m.ascensions = nil
	m.clearedascensions = false
	m.removedascensions = nil
}

// Where appends a list predicates to the ServantMutation builder.
func (m *ServantMutation) Where(ps ...predicate.Servant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Servant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Servant).
func (m *ServantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServantMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, servant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servant.FieldUpdatedAt)
	}
	if m.collection_no != nil {
		fields = append(fields, servant.FieldCollectionNo)
	}
	if m.name != nil {
		fields = append(fields, servant.FieldName)
	}
	if m.face != nil {
		fields = append(fields, servant.FieldFace)
	}
	if m.class != nil {
		fields = append(fields, servant.FieldClassID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servant.FieldCreatedAt:
		return m.CreatedAt()
	case servant.FieldUpdatedAt:
		return m.UpdatedAt()
	case servant.FieldCollectionNo:
		return m.CollectionNo()
	case servant.FieldName:
		return m.Name()
	case servant.FieldFace:
		return m.Face()
	case servant.FieldClassID:
		return m.ClassID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servant.FieldCollectionNo:
		return m.OldCollectionNo(ctx)
	case servant.FieldName:
		return m.OldName(ctx)
	case servant.FieldFace:
		return m.OldFace(ctx)
	case servant.FieldClassID:
		return m.OldClassID(ctx)
	}
	return nil, fmt.Errorf("unknown Servant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servant.FieldCollectionNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionNo(v)
		return nil
	case servant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servant.FieldFace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFace(v)
		return nil
	case servant.FieldClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	}
	return fmt.Errorf("unknown Servant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServantMutation) AddedFields() []string {
	var fields []string
	if m.addcollection_no != nil {
		fields = append(fields, servant.FieldCollectionNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servant.FieldCollectionNo:
		return m.AddedCollectionNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servant.FieldCollectionNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCollectionNo(v)
		return nil
	}
	return fmt.Errorf("unknown Servant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Servant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServantMutation) ResetField(name string) error {
	switch name {
	case servant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servant.FieldCollectionNo:
		m.ResetCollectionNo()
		return nil
	case servant.FieldName:
		m.ResetName()
		return nil
	case servant.FieldFace:
		m.ResetFace()
		return nil
	case servant.FieldClassID:
		m.ResetClassID()
		return nil
	}
	return fmt.Errorf("unknown Servant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServantMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.class != nil {
		edges = append(edges, servant.EdgeClass)
	}
	if m.traits != nil {
		edges = append(edges, servant.EdgeTraits)
	}
	if m.ascensions != nil {
		edges = append(edges, servant.EdgeAscensions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servant.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case servant.EdgeTraits:
		ids := make([]ent.Value, 0, len(m.traits))
		for id := range m.traits {
			ids = append(ids, id)
		}
		return ids
	case servant.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.ascensions))
		for id := range m.ascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtraits != nil {
		edges = append(edges, servant.EdgeTraits)
	}
	if m.removedascensions != nil {
		edges = append(edges, servant.EdgeAscensions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servant.EdgeTraits:
		ids := make([]ent.Value, 0, len(m.removedtraits))
		for id := range m.removedtraits {
			ids = append(ids, id)
		}
		return ids
	case servant.EdgeAscensions:
		ids := make([]ent.Value, 0, len(m.removedascensions))
		for id := range m.removedascensions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclass {
		edges = append(edges, servant.EdgeClass)
	}
	if m.clearedtraits {
		edges = append(edges, servant.EdgeTraits)
	}
	if m.clearedascensions {
		edges = append(edges, servant.EdgeAscensions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServantMutation) EdgeCleared(name string) bool {
	switch name {
	case servant.EdgeClass:
		return m.clearedclass
	case servant.EdgeTraits:
		return m.clearedtraits
	case servant.EdgeAscensions:
		return m.clearedascensions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServantMutation) ClearEdge(name string) error {
	switch name {
	case servant.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Servant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServantMutation) ResetEdge(name string) error {
	switch name {
	case servant.EdgeClass:
		m.ResetClass()
		return nil
	case servant.EdgeTraits:
		m.ResetTraits()
		return nil
	case servant.EdgeAscensions:
		m.ResetAscensions()
		return nil
	}
	return fmt.Errorf("unknown Servant edge %s", name)
}

// TraitMutation represents an operation that mutates the Trait nodes in the graph.
type TraitMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name_en         *string
	name_ja         *string
	clearedFields   map[string]struct{}
	servants        map[int]struct{}
	removedservants map[int]struct{}
	clearedservants bool
	done            bool
	oldValue        func(context.Context) (*Trait, error)
	predicates      []predicate.Trait
}

var _ ent.Mutation = (*TraitMutation)(nil)

// traitOption allows management of the mutation configuration using functional options.
type traitOption func(*TraitMutation)

// newTraitMutation creates new mutation for the Trait entity.
func newTraitMutation(c config, op Op, opts ...traitOption) *TraitMutation {
	m := &TraitMutation{
		config:        c,
		op:            op,
		typ:           TypeTrait,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTraitID sets the ID field of the mutation.
func withTraitID(id int) traitOption {
	return func(m *TraitMutation) {
		var (
			err   error
			once  sync.Once
			value *Trait
		)
		m.oldValue = func(ctx context.Context) (*Trait, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trait.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrait sets the old Trait of the mutation.
func withTrait(node *Trait) traitOption {
	return func(m *TraitMutation) {
		m.oldValue = func(context.Context) (*Trait, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TraitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TraitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Trait entities.
func (m *TraitMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TraitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TraitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trait.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TraitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TraitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trait entity.
// If the Trait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TraitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TraitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TraitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trait entity.
// If the Trait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TraitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNameEn sets the "name_en" field.
func (m *TraitMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *TraitMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Trait entity.
// If the Trait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraitMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *TraitMutation) ResetNameEn() {
	m.name_en = nil
}

// SetNameJa sets the "name_ja" field.
func (m *TraitMutation) SetNameJa(s string) {
	m.name_ja = &s
}

// NameJa returns the value of the "name_ja" field in the mutation.
func (m *TraitMutation) NameJa() (r string, exists bool) {
	v := m.name_ja
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJa returns the old "name_ja" field's value of the Trait entity.
// If the Trait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraitMutation) OldNameJa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJa: %w", err)
	}
	return oldValue.NameJa, nil
}

// ClearNameJa clears the value of the "name_ja" field.
func (m *TraitMutation) ClearNameJa() {
	m.name_ja = nil
	m.clearedFields[trait.FieldNameJa] = struct{}{}
}

// NameJaCleared returns if the "name_ja" field was cleared in this mutation.
func (m *TraitMutation) NameJaCleared() bool {
	_, ok := m.clearedFields[trait.FieldNameJa]
	return ok
}

// ResetNameJa resets all changes to the "name_ja" field.
func (m *TraitMutation) ResetNameJa() {
	m.name_ja = nil
	delete(m.clearedFields, trait.FieldNameJa)
}

// AddServantIDs adds the "servants" edge to the Servant entity by ids.
func (m *TraitMutation) AddServantIDs(ids ...int) {
	if m.servants == nil {
		m.servants = make(map[int]struct{})
	}
	for i := range ids {
		m.servants[ids[i]] = struct{}{}
	}
}

// ClearServants clears the "servants" edge to the Servant entity.
func (m *TraitMutation) ClearServants() {
	m.clearedservants = true
}

// ServantsCleared reports if the "servants" edge to the Servant entity was cleared.
func (m *TraitMutation) ServantsCleared() bool {
	return m.clearedservants
}

// RemoveServantIDs removes the "servants" edge to the Servant entity by IDs.
func (m *TraitMutation) RemoveServantIDs(ids ...int) {
	if m.removedservants == nil {
		m.removedservants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.servants, ids[i])
		m.removedservants[ids[i]] = struct{}{}
	}
}

// RemovedServants returns the removed IDs of the "servants" edge to the Servant entity.
func (m *TraitMutation) RemovedServantsIDs() (ids []int) {
	for id := range m.removedservants {
		ids = append(ids, id)
	}
	return
}

// ServantsIDs returns the "servants" edge IDs in the mutation.
func (m *TraitMutation) ServantsIDs() (ids []int) {
	for id := range m.servants {
		ids = append(ids, id)
	}
	return
}

// ResetServants resets all changes to the "servants" edge.
func (m *TraitMutation) ResetServants() {
	m.servants = nil
	m.clearedservants = false
	m.removedservants = nil
}

// Where appends a list predicates to the TraitMutation builder.
func (m *TraitMutation) Where(ps ...predicate.Trait) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TraitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TraitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trait, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TraitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TraitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trait).
func (m *TraitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TraitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, trait.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trait.FieldUpdatedAt)
	}
	if m.name_en != nil {
		fields = append(fields, trait.FieldNameEn)
	}
	if m.name_ja != nil {
		fields = append(fields, trait.FieldNameJa)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TraitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trait.FieldCreatedAt:
		return m.CreatedAt()
	case trait.FieldUpdatedAt:
		return m.UpdatedAt()
	case trait.FieldNameEn:
		return m.NameEn()
	case trait.FieldNameJa:
		return m.NameJa()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TraitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trait.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trait.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trait.FieldNameEn:
		return m.OldNameEn(ctx)
	case trait.FieldNameJa:
		return m.OldNameJa(ctx)
	}
	return nil, fmt.Errorf("unknown Trait field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trait.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trait.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trait.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	case trait.FieldNameJa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJa(v)
		return nil
	}
	return fmt.Errorf("unknown Trait field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TraitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TraitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Trait numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TraitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trait.FieldNameJa) {
		fields = append(fields, trait.FieldNameJa)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TraitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TraitMutation) ClearField(name string) error {
	switch name {
	case trait.FieldNameJa:
		m.ClearNameJa()
		return nil
	}
	return fmt.Errorf("unknown Trait nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TraitMutation) ResetField(name string) error {
	switch name {
	case trait.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trait.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trait.FieldNameEn:
		m.ResetNameEn()
		return nil
	case trait.FieldNameJa:
		m.ResetNameJa()
		return nil
	}
	return fmt.Errorf("unknown Trait field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TraitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.servants != nil {
		edges = append(edges, trait.EdgeServants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TraitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trait.EdgeServants:
		ids := make([]ent.Value, 0, len(m.servants))
		for id := range m.servants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TraitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservants != nil {
		edges = append(edges, trait.EdgeServants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TraitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trait.EdgeServants:
		ids := make([]ent.Value, 0, len(m.removedservants))
		for id := range m.removedservants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TraitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservants {
		edges = append(edges, trait.EdgeServants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TraitMutation) EdgeCleared(name string) bool {
	switch name {
	case trait.EdgeServants:
		return m.clearedservants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TraitMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Trait unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TraitMutation) ResetEdge(name string) error {
	switch name {
	case trait.EdgeServants:
		m.ResetServants()
		return nil
	}
	return fmt.Errorf("unknown Trait edge %s", name)
}
